{"version":3,"sources":["XORCipher.js","App.js","serviceWorker.js","index.js"],"names":["key","data","o1","o2","o3","h2","h3","h4","bits","r","i","enc","b64_table","charAt","length","slice","b64_encode","_","map","c","charCodeAt","keyCharAt","xor_encrypt","String","fromCharCode","join","xor_decrypt","h1","result","indexOf","push","b64_decode","Math","floor","SECRET_KEY","App","state","content","secondsRemaining","timerRunning","generateContent","evt","shouldEncode","Cipher","setState","startTimer","handleChange","target","name","value","tick","stopTimer","displayResult","className","text","onCopy","handleCopy","alert","this","seconds","interval","setInterval","clearInterval","type","onChange","onClick","Component","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.1c15b57a.chunk.js","sourcesContent":["/* eslint-disable */\n// XORCipher - Super simple encryption using XOR and Base64\n//\n// Depends on [Underscore](http://underscorejs.org/).\n//\n// As a warning, this is **not** a secure encryption algorythm. It uses a very\n// simplistic keystore and will be easy to crack.\n//\n// The Base64 algorythm is a modification of the one used in phpjs.org\n// * http://phpjs.org/functions/base64_encode/\n// * http://phpjs.org/functions/base64_decode/\n//\n// Examples\n// --------\n//\n//     XORCipher.encode(\"test\", \"foobar\");   // => \"EgocFhUX\"\n//     XORCipher.decode(\"test\", \"EgocFhUX\"); // => \"foobar\"\n//\n// Copyright Â© 2013 Devin Weaver <suki@tritarget.org>\n//\n// This program is free software. It comes without any warranty, to\n// the extent permitted by applicable law. You can redistribute it\n// and/or modify it under the terms of the Do What The Fuck You Want\n// To Public License, Version 2, as published by Sam Hocevar. See\n// http://www.wtfpl.net/ for more details.\nimport _ from \"underscore\";\n\nexport default {\n  encode: function(key, data) {\n    data = xor_encrypt(key, data);\n    return b64_encode(data);\n  },\n  decode: function(key, data) {\n    data = b64_decode(data);\n    return xor_decrypt(key, data);\n  }\n};\n\nvar b64_table = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\nfunction b64_encode(data) {\n  var o1, o2, o3, h1, h2, h3, h4, bits, r, i = 0, enc = \"\";\n  if (!data) { return data; }\n  do {\n    o1 = data[i++];\n    o2 = data[i++];\n    o3 = data[i++];\n    bits = o1 << 16 | o2 << 8 | o3;\n    h1 = bits >> 18 & 0x3f;\n    h2 = bits >> 12 & 0x3f;\n    h3 = bits >> 6 & 0x3f;\n    h4 = bits & 0x3f;\n    enc += b64_table.charAt(h1) + b64_table.charAt(h2) + b64_table.charAt(h3) + b64_table.charAt(h4);\n  } while (i < data.length);\n  r = data.length % 3;\n  return (r ? enc.slice(0, r - 3) : enc) + \"===\".slice(r || 3);\n}\n\nfunction b64_decode(data) {\n  var o1, o2, o3, h1, h2, h3, h4, bits, i = 0, result = [];\n  if (!data) { return data; }\n  data += \"\";\n  do {\n    h1 = b64_table.indexOf(data.charAt(i++));\n    h2 = b64_table.indexOf(data.charAt(i++));\n    h3 = b64_table.indexOf(data.charAt(i++));\n    h4 = b64_table.indexOf(data.charAt(i++));\n    bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;\n    o1 = bits >> 16 & 0xff;\n    o2 = bits >> 8 & 0xff;\n    o3 = bits & 0xff;\n    result.push(o1);\n    if (h3 !== 64) {\n      result.push(o2);\n      if (h4 !== 64) {\n        result.push(o3);\n      }\n    }\n  } while (i < data.length);\n  return result;\n}\n\nfunction keyCharAt(key, i) {\n  return key.charCodeAt( Math.floor(i % key.length) );\n}\n\nfunction xor_encrypt(key, data) {\n  return _.map(data, function(c, i) {\n    return c.charCodeAt(0) ^ keyCharAt(key, i);\n  });\n}\n\nfunction xor_decrypt(key, data) {\n  return _.map(data, function(c, i) {\n    return String.fromCharCode( c ^ keyCharAt(key, i) );\n  }).join(\"\");\n}","import React, { Component } from 'react';\nimport { CopyToClipboard } from \"react-copy-to-clipboard\";\nimport Cipher from \"./XORCipher\";\nimport './App.css';\n\nconst SECRET_KEY = \"n2r3fn92rx92839x2398xe\";\n\nconst ENCODE_SECONDS = 0;\nconst DECODE_SECONDS = 60;\n\nclass App extends Component {\n  state = {\n    content: \"\",\n    result: \"\",\n    secondsRemaining: ENCODE_SECONDS,\n    timerRunning: false,\n  }\n\n  componentWillUnmount() {\n    this.stopTimer();\n  }\n\n  startTimer(seconds) {\n    this.stopTimer();\n\n    this.interval = setInterval(() => this.tick(), 1000);\n\n    this.setState({ timerRunning: true, secondsRemaining: seconds });\n  }\n\n  stopTimer() {\n    clearInterval(this.interval);\n    this.setState({ timerRunning: false });\n  }\n\n  generateContent = (evt, shouldEncode) => {\n    const {content} = this.state;\n    if (!content) return;\n\n    const result = shouldEncode \n      ? Cipher.encode(SECRET_KEY, content)\n      : Cipher.decode(SECRET_KEY, content);\n\n    this.setState({ result });\n\n    shouldEncode\n      ? this.startTimer(ENCODE_SECONDS)\n      : this.startTimer(DECODE_SECONDS);\n  }\n\n  handleChange = (evt) => {\n    const { name, value } = evt.target;\n\n    this.setState({ [name]: value });\n  }\n\n  tick = () => {\n    const { timerRunning, secondsRemaining } = this.state;\n\n    if (!timerRunning) return;\n    if (secondsRemaining <= 1)\n      this.stopTimer();\n\n    this.setState(state => ({\n      secondsRemaining: state.secondsRemaining - 1\n    }))\n  }\n\n  displayResult = () => {\n    const { timerRunning, secondsRemaining, result } = this.state;\n\n    if (timerRunning) \n      return <p className=\"countdown\">{ secondsRemaining }</p>\n    else if (secondsRemaining <= 0)\n      return (\n        <CopyToClipboard text={result} onCopy={this.handleCopy}>\n          <p className=\"result\">{result}</p>\n        </CopyToClipboard>\n      )\n  }\n\n  handleCopy = () => {\n    alert(\"Text copied!\");\n  }\n\n  render() {\n    const { content } = this.state;\n\n    return (\n      <div className=\"container\">\n        <h1 className=\"heading\">Cipher</h1>\n  \n        <input \n          className=\"content-input\" \n          type=\"text\" \n          name=\"content\" \n          value={content} \n          onChange={this.handleChange}\n        />\n  \n        <div className=\"btn__container\">\n          <button className=\"btn btn--encode\" onClick={(evt) => this.generateContent(evt, true)}>\n            Encode\n          </button>\n          <button className=\"btn btn--decode\" onClick={(evt) => this.generateContent(evt, false)}>\n            Decode\n          </button>\n        </div>\n\n        { this.displayResult() }\n      </div>\n    );\n  }\n}\n\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}